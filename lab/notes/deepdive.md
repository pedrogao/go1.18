# 深度探索 go

## 装箱

- interface{} 被设计成一个容器，但它本质上是指针，可以直接装载地址，用来实现装载值的话，实际的内存要分配在别的地方，并把内存地址存储在这里。
  （convT64的作用就是分配这个存储值的内存空间，实际上runtime中有一系列的这类函数，如convT32、convTstring和convTslice等。）
- 通过staticuint64s这种优化方式，能够反向推断出：被convT64分配的这个uint64，它的值在语义层面是不可修改的，是个类似const的常量，  
  这样设计主要是为了跟interface{}配合来模拟“装载值”。
- 至于为什么这个值不可修改，因为interface{}只是一个容器，它支持把数据装入和取出，但是不支持直接在容器里修改。这有些类似于Java和C#里的自动装箱，  
  只不过interface{}是个万能包装类。
- interface{}装载值的时候，必须单独拷贝一份，而不能直接让data存储原始变量的地址，  
  但是否堆分配还是要经过逃逸分析：值类型装箱后又涉及到逃逸的情况时，才会用到runtime中的一系列convT函数。

## 动态派发(多态)

对于接口这类动态类型，调用方法地址是运行时确认的，编译器无法直接生成。

对于动态派发来讲，编译阶段能够确定的有：

- （1）要调用的方法的名字；
- （2）方法的原型（参数与返回值列表）。

基于一个确定的接口类型和一个确定的具体类型，就能够唯一确定一个itab。

因此一个 itab 实际上是由一个定义的 interface{} 和 struct{} 来确定。

按照一般的思路，只有具体类型实现了该接口，才能够得到一个itab，进而缓存起来。但这样会有个问题，假如具体类型没有实现该接口，  
但是运行阶段有大量这样的类型断言，缓存中查不到对应的itab，就会每次都查询元数据的方法列表，从而显著影响性能。  
所以，Go会把有效、无效的itab都缓存起来，通过fun[0]加以区分。

## 包装方法

编译器会为接收者为值类型的方法生成接收者为指针类型的方法，也就是所谓的“包装方法”。

接口是不能直接使用值接收者方法的，这就是编译器生成包装方法的根本原因。

- 生成包装方法主要是为了支持接口；
- 包装方法会经过链接器裁剪，不一定会存在于可执行文件中。

## 调度

goroutine的调度器也用到了时间片算法，但是和操作系统的线程调度还是有些区别的，因为整个Go程序都是运行在用户态的，  
所以不能像操作系统那样利用时钟中断来打断运行中的goroutine。也得益于完全在用户态实现，goroutine的调度切换更加轻量。

1.13之前的抢占依赖于goroutine检测到stackPreempt标识而自动让出，并不算是真正意义上的抢占。

1.14版本中，Go语言实现了真正的抢占式调度，这种“真正”的抢占是如何实现的呢？在Unix系操作系统上是基于信号来实现的，所以也称为异步抢占。



